
Хто я? Миронюк Павло Ярославович. Software Developer. Люблю Rust, знаю JS, можу писати на Java. Сьогодні розкажу вам чому я люблю Rust і вважаю його найкращою мовою для backend розробки і не тільки.

Я не буду розказуваити детально де використовується Rust. Якщо це вас дуже сильно цікавить, то подивіться на цю цікаву статистику: [Rust Programming - The State of Developer Ecosystem in 2021 Infographic](https://www.jetbrains.com/lp/devecosystem-2021/rust/).

## Зміст:

* Що тае Rust?
* Чому він класний?
* Мінуси Rust
* Як вчити Rust? Із чого почати?
* Післямова


## Що таке Rust?

[Вікіпедія](https://en.wikipedia.org/wiki/Rust_(programming_language)) нам каже, що:

`Rust is a multi-paradigm, high-level, general-purpose programming language designed for performance and safety, especially safe concurrency. Rust is syntactically similar to C++, but can guarantee memory safety by using a borrow checker to validate references. Rust achieves memory safety without garbage collection, and reference counting is optional.`

В загальному це хороше визначення, хоча, звичайно, повністю не розкариває суті Rust-а. Єдине із чим я не згодний, то це слова про схожість із синтаксисом С++. На мою думку це не так. Я залишу тут статтю на Habr ([Так ли токсичен синтаксис Rust?](https://habr.com/ru/post/532660/)) із аналізом синтаксису Rust. Далі я його обговорювати не буду, оскільки це справа смаку. Особисто мені він дуже подобається.

Перше, із чого я хочу почати, то це memoty model. І так, Rust в нас повністю compile мова. Тобто ваший вихідний код компілюється у виконуваний файл (.exe on Windows and binary file on Linux. Like in C/C++). Тут не має ніякого інтерпретатора, віртуальної машини чи garbage collector-а (як в Java, JS, python). Не має ніякого фонового процесу, який шукав би та видаляв би куски непотрібної пам'яті. Це означає, що інструкції для видалення пам'яті вже закладені всередині отриманого виконуваного файлу після компіляції. Як ці інструкції там з'являються? Якщо ми візьмемо для прикладу С++, то там ми руками вказуємо коли і який кусок пам'яті видалити `delete ptr;`. Така система має багато незручностей: ми можемо випадково не видалити якусь пам'ять (тоді буде memory leak), ми можемо спробувати видалити пам'ять яка вже видалена (тоді програма просто ~~крашнеться~~). В Rust-і ми явно не вказуємо який кусок пам'яті коли видаляти. Справа в тому, що на етапі компіляції компілятор сам ставить в потрібних місцях інструкції для видалення конкретних областей пам'яті (умовно він сам розставляє `delete ptr;`). Це є найкласніша штука в Rust: компілятор нам завжди гарантує, що в нас не буде меморі ліка (це не на 100% правда, потім роскажу чому). Саме тому всі кажуть, що він `designed for performance and safety, especially safe concurrency and can guarantee memory safety`. 

Тут виникає логічне питання: як компілятор розуміє, що певна область пам'яті нам не потрібна? Відповідь в наступному розділі.

## Чому він класний?

### Borrow checker

Я не буду сильно вдаватися в деталі як працює Rust. Просто пару речень для загального розуміння.

Давайте введемо три правила:

1. Кожне значення має свого власника (owner).
2. В кожного значення тільки один власник. 
3. Коли власник виходить за межі свого контексту (scope), то це значення видаляється (пам'ять, виділена під це значення, очищається).

Це є три фунтаментальні правила, за якими працює Rust. Що означає контекст (scope) я тут пояснювати не буду, оскільки припускаю, що ви знаєте що це таке. Тільки зауважу, що в Rust можна створювати власні контексти, як в JS:

```Rust
fn main() {
    {
        // new scope
        println!("Hello, world!");
    }
}
```

Приклад видалення пам'яті, коли власник виходить із свого контексту (також цей приклад показує що таке take ownership):

```Rust
fn debug(msg: String) {
    println!("{}", msg);
}

fn main() {
    let name = "Pavlo".to_owned();
    println!("Author: {}", name); // ok
    debug(name);
    println!("Author: {}", name); // error. Memory of name already deleted
}
```

Коротко про те, що сталося. Спочатку `name` є власником пам'яті, виділеною під ім'я, та тримає це значення. Коли ми викликали функцію `debug` із параметром `name`, то власником цього значення стала змінна `msg`. Тут відбулася передача "прав" на значення, змінився власник (take ownership). Це означає, що в кінці функції `debug` змінна `msg` вийде за межі свого контексту і її значення буде видалено. Тобто після виклику функції `debug`, значення `"Pavlo"` буде видалене.

Насправді в кінці функції `debug` компілятор поставить спеціальну інструкцію, яка видалить значення `msg`. Саме через це Rust не гарантує ніде хвостової рекурсії. Навіть якщо ми напишемо функцію, на перший погляд, із хвостовою рекурсією, то компілятор може дописати інструкції видалення пам'яті (і наша хвостова рекурсія вже не буде хвостовою :smile: ).

Що робити, якщо нам потрібно передати значення у функцію, але потім його знову використовувати? Рішення: використовувати силки (references). Ось перероблений код:

```Rust
fn debug(msg: &String) {
    println!("{}", msg);
}

fn main() {
    let name = "Pavlo".to_owned();
    println!("Author: {}", name); // ok
    debug(&name);
    println!("Author: {}", name); // ok
}
```

Примітка. Якщо ви працюєте із рядками, то краще використовувати `&str`.

Звичайна посилання (`&`) є імутабельна (immutable). Тобто на прикладі вище ми не можемо змінити значення `msg`. Щоб ми могли його змінити, треба використовувати мутабельні силки (mutable references `&mut`). Приклад:

```Rust
fn debug(msg: &mut String) {
    println!("msg: {}", msg); // msg: Pavlo
    msg.push_str(" Myroniuk");
}

fn main() {
    let mut name = "Pavlo".to_owned();
    println!("Author: {}", name); // Author: Pavlo
    debug(&mut name);
    println!("Author: {}", name); // Author: Pavlo Myroniuk
}
```

На кожне значення може бути тільки одна мутабельна посилання або багато імутабельних. Та штука, яка перевіряє передачу прав на значення, правильність використання силок і так далі, це `borrow checker`. Саме він буде казати, що ви дибіл, коли  перший раз компілюватимете свою програму на Rust :smile: (і скаже це не раз).

### No `null`


Да, в Rust не має `null`. Ви ніяк не зробите "заглушку". Якщо вам не потрібно відразу ініціалізовувати значення, наприклад, рядка, то у вас два варіанти:

1. Просто написати `let mut msg = "";`
2. Використовувати [`Option`](https://doc.rust-lang.org/std/option/). Приклад:
```Rust
let mut msg = Option::None;
// do some work and get the result
msg = Option::Some("some text");
```

Якщо у вас із функції не завжди вертається об'єкт, то замість того, щоб вертати `null`, найкращим способом буде використвоувати `Option`.

Якщо ви не впевнені, що відсутність `null`, це дуже і дуже класно, то почитайте [The billion dollar mistake](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/).

### No `exceptions`

Да, тут Rust теж обділили :) В нього не має ексепшинів, як всіх привичних нам мовах (like Java, JS, etc). Якщо у нас виникла десь помилка, то є два варіанти:

1. Якщо помилка не страшна і не критична для програми, то функція нехай вертає [Result](https://doc.rust-lang.org/std/result/).
2. Якщо це критична помилка і відновлення неможливе, то ми панікуємо `panic!("error msg")`. В такому випадку робота програми закінчиться та повернеться повідомлення, яке ми передали в макрос `panic!`.

На перший погляд може здатися, що кожен раз перевіряти, що вернула фкункція `Result::Ok` чи `Result::Err`, є не сильно зручно і заморочно, але це направді не так. У Rust є багато способів обробки помилок. Детальніше почитайте в цій [статті]().

### Patterns

### Деякі інші плюшки

Як то кажуть: дрібниці, але приємно.

* Shadowing
* Immutability
* Scalar types
* Tuples
* Макроси

## Мінуси Rust

None

## Як вчити Rust? Із чого почати?

## Післямова

У цій статті я розказав, чому вважаю Rust дуже класною мп. Якщо вам сподобалася ця стаття, то ви можете:

* Follow me on Github: [@TheBestTvarynka](https://github.com/TheBestTvarynka). Поки що там не сильно великий актив, але коли я вирішу деякі питання, то продовжу контрібютити в open source
* Endorse me Rust skill on LinkedIn: [thebesttvarynka](https://www.linkedin.com/in/thebesttvarynka/) (I'll accept every connection request)

Чи будуть ще статті? Скоріш так, ніж ні, але не найближчим часом. Можлива наступна стаття буде про потоки, мультизадачність та асинхронність в Rust. Можливо про web development в Rust. Мижливо на обидві теми відразу. Залежить від того, як складеться моє майбутнє.
